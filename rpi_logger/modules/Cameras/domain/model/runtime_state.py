"""Model definitions and persistence helpers for the Cameras runtime."""

from __future__ import annotations

import asyncio
import logging
import re
import shutil
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any, Optional

from rpi_logger.core.logging_utils import get_module_logger

module_logger = get_module_logger(__name__)

try:
    from rpi_logger.modules.Cameras.camera_core.config.config_loader import (
        DEFAULT_OVERLAY_CONFIG as CAMERA_OVERLAY_DEFAULTS,
    )
except ModuleNotFoundError:
    module_logger.debug("camera_core overlay defaults unavailable; using fallback values")
    CAMERA_OVERLAY_DEFAULTS = {
        'resolution_preset': 0,
        'resolution_width': 1920,
        'resolution_height': 1080,
        'preview_preset': 5,
        'preview_width': 640,
        'preview_height': 360,
        'target_fps': 30.0,
        'min_cameras': 1,
        'allow_partial': True,
        'discovery_timeout': 5.0,
        'discovery_retry': 3.0,
        'output_dir': 'recordings',
        'session_prefix': 'session',
        'auto_start_recording': False,
        'show_preview': True,
        'console_output': False,
        'libcamera_log_level': 'WARN',
        'font_scale_base': 0.6,
        'thickness_base': 2,
        'font_type': 'SIMPLEX',
        'outline_enabled': True,
        'outline_extra_thickness': 2,
        'line_start_y': 30,
        'line_spacing': 30,
        'margin_left': 10,
        'text_color_b': 255,
        'text_color_g': 255,
        'text_color_r': 255,
        'outline_color_b': 0,
        'outline_color_g': 0,
        'outline_color_r': 0,
        'line_type': 16,
        'background_enabled': False,
        'background_shape': 'rectangle',
        'background_color_b': 0,
        'background_color_g': 0,
        'background_color_r': 0,
        'background_opacity': 0.6,
        'background_padding_top': 10,
        'background_padding_bottom': 10,
        'background_padding_left': 10,
        'background_padding_right': 10,
        'background_corner_radius': 10,
        'show_camera_and_time': True,
        'show_session': True,
        'show_requested_fps': True,
        'show_sensor_fps': True,
        'show_display_fps': True,
        'show_frame_counter': True,
        'show_recording_info': True,
        'show_recording_filename': True,
        'show_controls': True,
        'show_frame_number': True,
        'scale_mode': 'auto',
        'manual_scale_factor': 3.0,
        'enable_csv_timing_log': True,
        'disable_mp4_conversion': True,
    }

from rpi_logger.core.config_manager import get_config_manager
from vmc.constants import PLACEHOLDER_GEOMETRY


@dataclass(slots=True)
class FramePayload:
    """Container for a captured frame propagated through preview/storage pipelines."""

    frame: Any
    timestamp: float
    monotonic: float
    metadata: Optional[dict[str, Any]]
    pixel_format: str
    stream: str
    capture_index: int
    hardware_frame_number: Optional[int]
    dropped_since_last: Optional[int]
    sensor_timestamp_ns: Optional[int]


@dataclass(slots=True)
class CapturedFrame:
    """Minimal payload generated by the tight capture loop."""

    frame: Any
    metadata: dict[str, Any]
    timestamp: float
    monotonic: float
    preview_frame: Optional[Any] = None


@dataclass(slots=True)
class FrameGate:
    """Simple gate that rate-limits frame emission to a desired period."""

    period: float = 0.0
    start: float = -1.0
    tick: int = 0

    def configure(self, period: float) -> None:
        self.period = max(0.0, float(period))
        self.start = -1.0
        self.tick = 0

    def should_emit(self, now: float) -> bool:
        if self.period <= 0.0:
            return True
        if self.start < 0.0:
            self.start = now
            self.tick = 1
            return True
        target = self.start + self.tick * self.period
        tolerance = min(self.period * 0.2, 0.02)  # allow modest early arrivals
        if now + tolerance < target:
            return False
        slots_elapsed = int((now - self.start) / self.period) + 1
        self.tick = max(self.tick + 1, slots_elapsed)
        return True


class CameraModel:
    """Holds runtime configuration, persistence helpers, and shared state."""

    PREVIEW_SIZE = (640, 480)
    UPDATE_INTERVAL = 0.2  # seconds
    MAX_SENSOR_FPS = 60.0
    MAX_NATIVE_SIZE = (1440, 1080)
    NATIVE_ASPECT = MAX_NATIVE_SIZE[1] / MAX_NATIVE_SIZE[0]
    STORAGE_QUEUE_DEFAULT = 8
    SESSION_RETENTION_DEFAULT = 5
    MIN_FREE_SPACE_MB_DEFAULT = 512

    def __init__(
        self,
        *,
        args,
        module_dir: Path,
        display_name: str,
        logger: logging.Logger,
        config_path: Optional[Path] = None,
    ) -> None:
        self.args = args
        self.module_dir = module_dir
        self.display_name = display_name
        self.logger = logger
        self.config_path = config_path or (module_dir / "config.txt")
        self.overlay_config = dict(CAMERA_OVERLAY_DEFAULTS)
        self.camera_aliases: dict[int, str] = {}
        self._camera_alias_slugs: dict[int, str] = {}

        self._status_message = "Initializing"
        self.ensure_module_config()
        self.apply_saved_preferences()

        self.save_frame_interval = self._compute_save_interval()
        self.preview_fraction = self._compute_preview_fraction()
        self.preview_frame_interval = self._compute_preview_interval()

        self.save_enabled = bool(getattr(self.args, "save_images", False))
        self.capture_preferences_enabled = bool(self.save_enabled)

        self.save_format = self._compute_save_format()
        self.save_quality = self._compute_save_quality()


        retention_arg = self._safe_int(getattr(self.args, "session_retention", self.SESSION_RETENTION_DEFAULT))
        self.session_retention = max(0, retention_arg or self.SESSION_RETENTION_DEFAULT)

        free_space_arg = self._safe_int(getattr(self.args, "min_free_space_mb", self.MIN_FREE_SPACE_MB_DEFAULT))
        self.min_free_space_mb = max(0, free_space_arg or self.MIN_FREE_SPACE_MB_DEFAULT)

        queue_size_arg = self._safe_int(getattr(self.args, "storage_queue_size", self.STORAGE_QUEUE_DEFAULT))
        self.storage_queue_size = max(1, queue_size_arg or self.STORAGE_QUEUE_DEFAULT)

        self.save_dir: Optional[Path] = None
        self.session_dir: Optional[Path] = None
        if self.save_enabled:
            base_dir = self.resolve_save_dir()
            if base_dir:
                session_dir = self.prepare_session_directory_sync(base_dir)
                if session_dir is None:
                    self.logger.error("Initial recording session unavailable; saving disabled")
                    self.save_enabled = False
                else:
                    self.save_dir = base_dir
                    self.session_dir = session_dir
            else:
                self.logger.error("Unable to determine save directory; saving disabled")
                self.save_enabled = False

    # ------------------------------------------------------------------
    # Status helpers
    # ------------------------------------------------------------------
    @property
    def status_message(self) -> str:
        return self._status_message

    def update_status(self, message: str, *, level: int = logging.INFO) -> None:
        if message == self._status_message:
            return
        self._status_message = message
        try:
            self.logger.log(level, "Status -> %s", message)
        except Exception:  # pragma: no cover - defensive
            self.logger.info("Status -> %s", message)

    # ------------------------------------------------------------------
    # Preference persistence
    # ------------------------------------------------------------------
    def ensure_module_config(self) -> None:
        path = self.config_path
        try:
            path.parent.mkdir(parents=True, exist_ok=True)
        except Exception:  # pragma: no cover - defensive
            return
        if path.exists():
            return
        defaults = {
            "enabled": "false",
            "display_name": self.display_name,
            "window_geometry": PLACEHOLDER_GEOMETRY,
            "preview_fraction": "1.0",
            "preview_fps": "unlimited",
            "save_width": str(self.PREVIEW_SIZE[0]),
            "save_height": str(self.PREVIEW_SIZE[1]),
            "save_fps": "unlimited",
            "save_format": "jpeg",
            "save_quality": "90",
            "camera_1_alias": "Camera 1",
            "camera_2_alias": "Camera 2",
        }
        lines = [f"{key} = {value}" for key, value in defaults.items()]
        try:
            path.write_text("\n".join(lines) + "\n", encoding="utf-8")
        except Exception:  # pragma: no cover - defensive
            pass

    def apply_saved_preferences(self) -> None:
        config = self._read_module_config()
        updates: dict[str, Any] = {}
        if not config:
            self._load_camera_aliases({}, updates)
            if updates:
                self._write_module_preferences_sync(updates)
            return

        preview_fraction_raw = config.get("preview_fraction")
        preview_fraction_value = self._safe_float(preview_fraction_raw)
        if preview_fraction_value is not None and preview_fraction_value > 0:
            setattr(self.args, "preview_fraction", preview_fraction_value)
        preview_fps = config.get("preview_fps")
        preview_fps_value = self._safe_float(preview_fps)
        if preview_fps_value is not None and preview_fps_value > 0:
            setattr(self.args, "preview_fps", preview_fps_value)
            if str(preview_fps_value) != str(preview_fps):
                updates["preview_fps"] = float(preview_fps_value)
        else:
            setattr(self.args, "preview_fps", None)
            if preview_fps not in {"unlimited", "none", "0", None}:
                updates["preview_fps"] = "unlimited"

        save_w = self._safe_int(config.get("save_width"))
        save_h = self._safe_int(config.get("save_height"))
        if save_w is not None and save_h is not None:
            setattr(self.args, "save_width", save_w)
            setattr(self.args, "save_height", save_h)
            if config.get("save_width") != str(save_w):
                updates["save_width"] = save_w
            if config.get("save_height") != str(save_h):
                updates["save_height"] = save_h

        save_fps = config.get("save_fps")
        save_fps_value = self._safe_float(save_fps)
        if save_fps_value is not None and save_fps_value > 0:
            setattr(self.args, "save_fps", save_fps_value)
            if str(save_fps_value) != str(save_fps):
                updates["save_fps"] = float(save_fps_value)
        else:
            setattr(self.args, "save_fps", None)
            if save_fps not in {"unlimited", "none", "0", None}:
                updates["save_fps"] = "unlimited"

        fmt = config.get("save_format")
        if isinstance(fmt, str) and fmt.strip():
            normalized_fmt = fmt.strip().lower()
            setattr(self.args, "save_format", normalized_fmt)
            if config.get("save_format") != normalized_fmt:
                updates["save_format"] = normalized_fmt

        quality = self._safe_int(config.get("save_quality"))
        if quality is not None:
            setattr(self.args, "save_quality", quality)
            if config.get("save_quality") != str(quality):
                updates["save_quality"] = quality

        self._load_camera_aliases(config, updates)

        if updates:
            self._write_module_preferences_sync(updates)

    def _read_module_config(self) -> dict[str, Any]:
        path = self.config_path
        if not path.exists():
            return {}
        try:
            return get_config_manager().read_config(path)
        except Exception as exc:  # pragma: no cover - defensive
            self.logger.debug("Config read failed: %s", exc)
            return {}

    async def persist_module_preferences(self) -> None:
        path = self.config_path
        if not path.exists():
            return

        updates: dict[str, Any] = {}
        preview_fps = getattr(self.args, "preview_fps", None)
        if preview_fps is None or preview_fps <= 0:
            updates["preview_fps"] = "unlimited"
        else:
            updates["preview_fps"] = float(preview_fps)
        updates["preview_fraction"] = getattr(self.args, "preview_fraction", self.preview_fraction)

        save_w = getattr(self.args, "save_width", None)
        save_h = getattr(self.args, "save_height", None)
        if save_w is not None:
            updates["save_width"] = save_w
        if save_h is not None:
            updates["save_height"] = save_h

        save_fps = getattr(self.args, "save_fps", None)
        if save_fps is None or save_fps <= 0:
            updates["save_fps"] = "unlimited"
        else:
            updates["save_fps"] = float(save_fps)

        updates["save_format"] = getattr(self.args, "save_format", self.save_format)
        updates["save_quality"] = getattr(self.args, "save_quality", self.save_quality)

        for idx, alias in self.camera_aliases.items():
            updates[f"camera_{idx + 1}_alias"] = alias

        if not updates:
            return

        config_manager = get_config_manager()
        try:
            success = await config_manager.write_config_async(path, updates)
        except Exception as exc:  # pragma: no cover - defensive
            self.logger.warning("Failed to persist module prefs: %s", exc)
            return

        if not success:
            self.logger.warning("Unable to write module prefs to %s", path)

    def _write_module_preferences_sync(self, updates: dict[str, Any]) -> None:
        path = self.config_path
        if not path.exists() or not updates:
            return
        try:
            get_config_manager().write_config(path, updates)
        except Exception as exc:  # pragma: no cover - defensive
            self.logger.debug("Failed to sync-write module prefs: %s", exc)

    # ------------------------------------------------------------------
    # Camera alias helpers
    # ------------------------------------------------------------------
    def _load_camera_aliases(self, config: dict[str, Any], updates: dict[str, Any]) -> None:
        alias_count = self._camera_alias_count()
        aliases: dict[int, str] = {}
        for idx in range(alias_count):
            key = f"camera_{idx + 1}_alias"
            raw_value = config.get(key)
            alias = self._sanitize_alias(raw_value, idx)
            aliases[idx] = alias
            if not isinstance(raw_value, str) or raw_value.strip() != alias:
                updates[key] = alias
        self.camera_aliases = aliases
        self._camera_alias_slugs = self._build_alias_slugs(aliases)

    def _camera_alias_count(self) -> int:
        max_cams = self._safe_int(getattr(self.args, "max_cameras", None))
        if max_cams is None or max_cams <= 0:
            max_cams = 2
        return max(2, max_cams)

    def _sanitize_alias(self, value: Any, index: int) -> str:
        if isinstance(value, str):
            cleaned = value.strip()
            if cleaned:
                return cleaned
        return self._default_camera_alias(index)

    @staticmethod
    def _default_camera_alias(index: int) -> str:
        return f"Camera {index + 1}"

    def get_camera_alias(self, index: int) -> str:
        return self.camera_aliases.get(index, self._default_camera_alias(index))

    def get_camera_alias_slug(self, index: int) -> str:
        if not self._camera_alias_slugs:
            self._camera_alias_slugs = self._build_alias_slugs(self.camera_aliases)
        return self._camera_alias_slugs.get(index, self._default_camera_slug(index))

    def _build_alias_slugs(self, aliases: dict[int, str]) -> dict[int, str]:
        seen: dict[str, int] = {}
        slugs: dict[int, str] = {}
        for idx, alias in aliases.items():
            candidate = self._slugify_alias(alias)
            if not candidate:
                candidate = self._default_camera_slug(idx)
            normalized = candidate.lower()
            occurrence = seen.get(normalized, 0)
            seen[normalized] = occurrence + 1
            slug = candidate if occurrence == 0 else f"{candidate}_{occurrence + 1}"
            slugs[idx] = slug
        return slugs

    @staticmethod
    def _slugify_alias(alias: str) -> str:
        if not isinstance(alias, str):
            return ""
        return re.sub(r"[^A-Za-z0-9]+", "_", alias).strip("_")

    @staticmethod
    def _default_camera_slug(index: int) -> str:
        return f"Camera_{index + 1}"

    # ------------------------------------------------------------------
    # Directory helpers
    # ------------------------------------------------------------------
    def resolve_save_dir(self) -> Path:
        explicit = getattr(self.args, "save_dir", None)
        if explicit:
            return Path(explicit)

        output_root = getattr(self.args, "output_dir", None)
        if output_root:
            base = Path(output_root)
        else:
            base = Path.cwd() / "cameras"
        return base / "captures"

    def prepare_session_directory_sync(self, base_dir: Path) -> Optional[Path]:
        try:
            base_dir.mkdir(parents=True, exist_ok=True)
        except Exception as exc:  # pragma: no cover - defensive
            self.logger.error("Unable to prepare base save directory %s: %s", base_dir, exc)
            return None

        if not self._has_min_free_space(base_dir):
            self.logger.error(
                "Insufficient free space (need %d MB) for recordings in %s",
                self.min_free_space_mb,
                base_dir,
            )
            return None

        try:
            self._prune_old_sessions_sync(base_dir)
            return self._create_session_dir_sync(base_dir)
        except Exception as exc:  # pragma: no cover - defensive
            self.logger.error("Failed to create session directory under %s: %s", base_dir, exc)
            return None

    async def prepare_session_directory(self, base_dir: Path) -> Optional[Path]:
        return await asyncio.to_thread(self.prepare_session_directory_sync, base_dir)

    def ensure_camera_dir_sync(self, camera_index: int, session_dir: Path) -> Path:
        camera_dir_name = self.get_camera_alias_slug(camera_index)
        camera_dir = session_dir / camera_dir_name
        camera_dir.mkdir(parents=True, exist_ok=True)
        return camera_dir

    def _create_session_dir_sync(self, base_dir: Path) -> Path:
        timestamp = datetime.utcnow().strftime("session_%Y%m%d_%H%M%S")
        for attempt in range(50):
            suffix = f"_{attempt:02d}" if attempt else ""
            candidate = base_dir / f"{timestamp}{suffix}"
            if not candidate.exists():
                candidate.mkdir(parents=False, exist_ok=False)
                return candidate
        raise RuntimeError("Unable to allocate unique session directory")

    def _prune_old_sessions_sync(self, base_dir: Path) -> None:
        if self.session_retention <= 0:
            return
        try:
            entries = [
                path
                for path in base_dir.iterdir()
                if path.is_dir() and path.name.startswith("session_")
            ]
        except FileNotFoundError:
            return
        entries.sort(key=lambda path: path.stat().st_mtime, reverse=True)
        for obsolete in entries[self.session_retention :]:
            try:
                shutil.rmtree(obsolete)
                self.logger.info("Pruned old session %s", obsolete)
            except Exception as exc:  # pragma: no cover - defensive
                self.logger.warning("Unable to prune session %s: %s", obsolete, exc)

    def _has_min_free_space(self, path: Path) -> bool:
        if self.min_free_space_mb <= 0:
            return True
        try:
            usage = shutil.disk_usage(path)
        except Exception as exc:  # pragma: no cover - defensive
            self.logger.debug("Disk usage probe failed for %s: %s", path, exc)
            return True
        return usage.free >= self.min_free_space_mb * 1024 * 1024

    # ------------------------------------------------------------------
    # Camera geometry helpers
    # ------------------------------------------------------------------
    def resolve_sensor_resolution(self, camera: Any) -> Optional[tuple[int, int]]:
        size = self.normalize_size(getattr(camera, "sensor_resolution", None))
        if size:
            return self.clamp_resolution(size[0], size[1], self.MAX_NATIVE_SIZE)

        properties = getattr(camera, "camera_properties", None)
        if isinstance(properties, dict):
            size = self.normalize_size(properties.get("PixelArraySize"))
            if size:
                return self.clamp_resolution(size[0], size[1], self.MAX_NATIVE_SIZE)
        return self.MAX_NATIVE_SIZE

    def coerce_capture_size(self, native_size: Optional[tuple[int, int]]) -> Optional[tuple[int, int]]:
        width = self._safe_int(getattr(self.args, "capture_width", None))
        height = self._safe_int(getattr(self.args, "capture_height", None))

        if width is None and height is None:
            return native_size

        native = self.normalize_size(native_size) or self.MAX_NATIVE_SIZE

        if width is not None and height is not None:
            width, height = self.enforce_native_aspect(width, height)
            return self.clamp_resolution(width, height, native)

        if width is not None:
            target_height = int(round(width * self.NATIVE_ASPECT))
            return self.clamp_resolution(width, target_height, native)

        if height is not None:
            target_width = int(round(height / self.NATIVE_ASPECT))
            return self.clamp_resolution(target_width, height, native)

        return native

    def coerce_save_size(self, capture_size: Optional[tuple[int, int]]) -> Optional[tuple[int, int]]:
        width = self._safe_int(getattr(self.args, "save_width", None))
        height = self._safe_int(getattr(self.args, "save_height", None))

        if width is None and height is None:
            return capture_size

        base = self.normalize_size(capture_size) or self.PREVIEW_SIZE

        if width is not None and height is not None:
            width, height = self.enforce_native_aspect(width, height)
            return self.clamp_resolution(width, height, base)

        if width is not None:
            target_height = int(round(width * self.NATIVE_ASPECT))
            return self.clamp_resolution(width, target_height, base)

        if height is not None:
            target_width = int(round(height / self.NATIVE_ASPECT))
            return self.clamp_resolution(target_width, height, base)

        return base

    def clamp_resolution(
        self,
        width: int,
        height: int,
        native: Optional[tuple[int, int]] = None,
    ) -> tuple[int, int]:
        max_width, max_height = self.MAX_NATIVE_SIZE
        if native:
            max_width = min(max_width, native[0])
            max_height = min(max_height, native[1])
        width = max(160, min(width, max_width))
        height = max(120, min(height, max_height))
        return width, height

    def enforce_native_aspect(self, width: int, height: int) -> tuple[int, int]:
        if width <= 0 or height <= 0:
            return width, height
        target_height = int(round(width * self.NATIVE_ASPECT))
        target_width = int(round(height / self.NATIVE_ASPECT))

        adjusted_width, adjusted_height = width, height
        if abs(target_height - height) <= abs(target_width - width):
            adjusted_height = target_height
        else:
            adjusted_width = target_width

        adjusted_width, adjusted_height = self._ensure_even_dimensions(adjusted_width, adjusted_height)
        return self.clamp_resolution(adjusted_width, adjusted_height, self.MAX_NATIVE_SIZE)

    @staticmethod
    def _ensure_even_dimensions(width: int, height: int) -> tuple[int, int]:
        if width % 2:
            width -= 1
        if height % 2:
            height -= 1
        return max(width, 2), max(height, 2)

    @staticmethod
    def normalize_size(value: Any) -> Optional[tuple[int, int]]:
        if not value:
            return None
        try:
            width, height = int(value[0]), int(value[1])
        except (TypeError, ValueError, IndexError):
            return None
        if width <= 0 or height <= 0:
            return None
        return width, height

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------
    def _compute_preview_fraction(self) -> float:
        raw_fraction = self._safe_float(getattr(self.args, "preview_fraction", None))
        if raw_fraction is not None and raw_fraction > 0:
            return self._clamp_fraction(raw_fraction)

        preview_fps_arg = self._safe_float(getattr(self.args, "preview_fps", None))
        if preview_fps_arg is not None and preview_fps_arg > 0 and self.save_frame_interval > 0:
            capture_fps = 1.0 / self.save_frame_interval
            if capture_fps > 0:
                return self._clamp_fraction(preview_fps_arg / capture_fps)

        return 1.0

    def _compute_preview_interval(self) -> float:
        base_interval = self.save_frame_interval if self.save_frame_interval > 0 else (1.0 / self.MAX_SENSOR_FPS)
        fraction = self.preview_fraction if self.preview_fraction > 0 else 1.0
        interval = base_interval / fraction
        return max(interval, 1.0 / self.MAX_SENSOR_FPS)

    def _compute_save_interval(self) -> float:
        save_fps_arg = getattr(self.args, "save_fps", None)
        if save_fps_arg is not None and save_fps_arg > 0:
            capped_save_fps = min(float(save_fps_arg), self.MAX_SENSOR_FPS)
            interval = 1.0 / capped_save_fps
        else:
            interval = 0.0
        return interval

    def _compute_save_format(self) -> str:
        save_format = getattr(self.args, "save_format", "jpeg") or "jpeg"
        normalized = str(save_format).lower()
        if normalized not in {"jpeg", "jpg", "png", "webp"}:
            normalized = "jpeg"
        setattr(self.args, "save_format", normalized)
        return normalized

    def _compute_save_quality(self) -> int:
        quality_arg = self._safe_int(getattr(self.args, "save_quality", 90))
        if quality_arg is None:
            quality_arg = 90
        quality = max(1, min(quality_arg, 100))
        setattr(self.args, "save_quality", quality)
        return quality

    @staticmethod
    def _safe_int(value: Any) -> Optional[int]:
        try:
            if value is None:
                return None
            return int(value)
        except (TypeError, ValueError):
            return None

    @staticmethod
    def _safe_float(value: Any) -> Optional[float]:
        try:
            if value is None:
                return None
            return float(value)
        except (TypeError, ValueError):
            return None

    @staticmethod
    def _clamp_fraction(value: float) -> float:
        return min(1.0, max(0.1, value))


__all__ = ["CameraModel", "FramePayload", "FrameGate"]
