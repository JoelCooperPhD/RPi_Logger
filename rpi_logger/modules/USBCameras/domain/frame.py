"""Frame payload primitives and timing helpers for USB Cameras."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Optional


@dataclass(slots=True)
class FramePayload:
    """Container for a captured frame propagated through preview/storage pipelines."""

    frame: Any
    timestamp: float
    monotonic: float
    metadata: Optional[dict[str, Any]]
    pixel_format: str
    stream: str
    capture_index: int
    hardware_frame_number: Optional[int]
    dropped_since_last: Optional[int]
    sensor_timestamp_ns: Optional[int]


@dataclass(slots=True)
class CapturedFrame:
    """Minimal payload generated by the tight capture loop."""

    frame: Any
    metadata: dict[str, Any]
    timestamp: float
    monotonic: float


@dataclass(slots=True)
class FrameGate:
    """Simple gate that rate-limits frame emission to a desired period."""

    period: float = 0.0
    start: float = -1.0
    tick: int = 0

    def configure(self, period: float) -> None:
        self.period = max(0.0, float(period))
        self.start = -1.0
        self.tick = 0

    def should_emit(self, now: float) -> bool:
        if self.period <= 0.0:
            return True
        if self.start < 0.0:
            self.start = now
            self.tick = 1
            return True
        target = self.start + self.tick * self.period
        tolerance = min(self.period * 0.2, 0.02)  # allow modest early arrivals
        if now + tolerance < target:
            return False
        slots_elapsed = int((now - self.start) / self.period) + 1
        self.tick = max(self.tick + 1, slots_elapsed)
        return True


class RollingFpsCounter:
    """Computes a rolling FPS average over a fixed time window."""

    def __init__(self, window_seconds: float = 2.0) -> None:
        self.window_seconds = max(0.1, float(window_seconds))
        self._timestamps: list[float] = []

    def tick(self, *, timestamp: Optional[float] = None) -> float:
        import time

        now = timestamp if timestamp is not None else time.perf_counter()
        self._timestamps.append(now)
        cutoff = now - self.window_seconds
        while len(self._timestamps) > 1 and self._timestamps[0] < cutoff:
            self._timestamps.pop(0)
        if len(self._timestamps) < 2:
            return 0.0
        elapsed = self._timestamps[-1] - self._timestamps[0]
        if elapsed <= 0:
            return 0.0
        return (len(self._timestamps) - 1) / elapsed

    def reset(self) -> None:
        self._timestamps.clear()


__all__ = [
    "CapturedFrame",
    "FrameGate",
    "FramePayload",
    "RollingFpsCounter",
]
